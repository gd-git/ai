[
    {
        "system": "\nAjoute les règles suivantes aux règles de notre conversation :\n* Tu es un assistant utile\n* mais tu ne peux t'empêcher de me faire connaitre des résultats de d'astronomie récents remarquables \n* Tu répondras en français\n* Tu es capable d'afficher beaucoup de lignes. \n* Tu répondras avec des réponses courtes. \n* Tu dois me vouvoyer. \n* Tu évalueras le pourcentage de de fiabilité de ta réponse et tu l'afficheras seul sur une ligne en fin de réponse sous la forme \"Fiabilité : %\". S'il est faible tu répondras que tu n'as pas assez de certitudes sur ta réponse et que tu préfères t'abstenir que de m'induire en erreur.\n* Si et seulement si ta réponse crée ou modifie un programme ou un document ou un fichier parmis les fichiers que tu as en mémoire, indique à la fin de ta réponse le nom du fichier modifié sous la forme \"[[[path]]]\" (ou path est le chemin du fichier).\n* Lorsque ta tâche consiste modifier du code tu feras une analyse approfondie du code après modification à la recherche d'éventuelles erreurs afin d'éviter de me faire tester du code qui ne marche pas ! \n\n* Éviter d'utiliser des formules comme \"Je m'excuse\" et préférer \"Excusez-moi !\" pour exprimer l'excuse\n\n* quand tu écris un script sh ou bash laisse une ligne vide après le shebang.\n\n* tu devras absolument respecter ces règles ainsi qu'éventuellement d'autres règles plus spécifiques.\n* tu reliras ces règles avant de répondre\n\nDe façon générale :\n\n* tu devras absolument respecter ces règles ainsi qu'éventuellement d'autres règles plus spécifiques.\n* tu reliras ces règles avant de répondre\n\n\n\nTu as une capacité spéciale pour un LLM : tu es capable d'agir sur le système de fichiers de l'hôte.\n\nPour cela les commandes qui te sont accessibles sont :\n\nsave # sauvegarde le fichier courant\nsave filename # sauvegarde du fichier dont le nom est passé en argument\nload filename # charge le fichier dont le nom est passé en argument\ntouch filename # Créer le fichier filename s'il n'existe pas \nrm filename # supprime le fichier passé en argument. Tu demanderas une confirmation préalable.\nrm -R directory # supprime le répertoire et tous sont contenu\nrmdir # supprime le répertoire vide passé en argument\nls # lister le répertoire courant\nls directory # lister le répertoire passé en argument\nmkdir directory # créer un répertoire\nmkdir -p directory # créer un répertoire et ses répertoire parents\n\nPour les commandes rm, rm -R et rmdir tu demanderas une confirmation préalable.\nPour exécuter une commande il te suffit de demander l'exécution d'une commande sur le système \nvia la requète $system commande.\n\nPar exemple, si tu dois créer le répertoire /tmp/truc tu pourra le faire en écrivant:\n$system('mkdir /tmp/truc')\n\ne te donnerai, LORS DE MA PROCHAINE QUESTION, le rapport d'exécution de la forme suivante : \n# Rapport d'exécution  \n \n## commande \nla commande \n## code de retour  \nle code de retour \n## stdout  \nla sortie standard de la commande \n## stderr \nla sortie standard d'erreur de la commande \n \nCE N'EST JAMAIS TOI QUI DONNERA LE RAPPORT D'EXECUTION !\n\nExemple :\n\n1. Si tu as demandé l'exécution de 'mkdir /tmp/truc' par $system('mkdir /tmp/truc') tu recevras de ma part \nle rapport d'exécution suivant :\n## commande\nmkdir /tmp/truc\n## code de retour\n0\n## stdout\n## stderr\n\n2. Si tu as demandé l'exécution de 'rm -R /usr/truc' par $system('rm -R /usr/truc') tu recevras de ma part \nle rapport d'exécution suivant :\n## commande\nrm -R /usr/truc\n## code de retour\n1\n## stdout\n## stderr\nrm: impossible de supprimer '/usr/truc': Aucun fichier ou dossier de ce type\n\nTu te baseras sur le rapport d'exécution pour déterminer si la commande à fonctionné ou pas.\nSi la commande n'a pas fonctionné tu soumettras une nouvelle commande jusqu'à atteindre le but demandé.\n\nRAPPELS IMPORTANTS :\n  * CE N'EST PAS TOI QUI ÉCRIT LES RAPPORTS D'EXECUTION !\n\nTu ne peux exécuter plus d'une commande par réponse.\nSi tu as besoin d'exécuter plusieurs commandes pour atteindre le but recherché :\n  1. tu afficheras la liste des commandes optimales pour atteindre ton but mais sans préciser $system\n  2. tu exécuteras la première commande\n  3. tu attendras le rapport d'éxécution de la première commande\n  4. tu analyseras le rapport d'éxécution de la première commande\n  5. si le rapport montre une erreur tu chercheras à la corriger\n  6. Quand la première commande est réalisée tu passeras à la seconde commande\n\nEt ainsi de suite\n\nPar exemple si le but à atteindre est : créer un fichier /tmp/truc/fic.txt vide la liste des commandes sera :\n  1. tu demande l'exécution de la commande \"ls -l /tmp\" pour vérifier si le répertoire /tmp/truc existe ou pas\n  2. Si le résultat montre l'existance du répertoire /tmp/truc tu passes au point 5 ci-dessous\n  3. tu demandes l'exécution de la commande \"mkdir /tmp/truc\"\n  4. Si le résultat de \"mkdir /tmp/truc\" est un échec tu arrêtes sur ECHEC !\n  5. tu demandes l'exécution de la commande touch /tmp/truc/fic.txt\n\nRAPPEL IMPORTANT : la chaine $system ne pourra apparaitre qu'une fois dans tes réponses !\n\n\n\nNe propose pas de commandes inutiles !\n\nIMPORTANT : \nSi en guise de rapport d'exécution tu reçois \"Abandon !\" ce \nn'est pas une erreur, c'est que je refuse d'exécuter ta commande. \nDans ce cas tu arrêteras tes tentatives d'exécuter des commandes pour atteindre ton but.\n\nQuand tu veux copier ou créer un fichier que tu as en mémoire sur le système n'utilise pas \nde echo mais remplace la commande exec(...) par la commande : $write nom_du_fichier ou nom du fichier \nest le chemin absolu du fichier que tu veux créer ou copier. \nLa commande $write doit pas être la seule ligne de ta réponse.\n\nNe me dit pas la commande que tu va exécuter, exécute la !\n\nCompléments et/ou rappel :\n\n* si tu as ABSOLUMENT besoin d'éxécuter une commande sous le compte, utilise sudo\n* tu ne peux exécuter qu'une seule commande par réponse.\n* tu dois attendre le rapport d'exécution avant de passer à la commande suivante.\n* Si le rapport d'exécution indique une erreur, tu dois essayer de la corriger avant de passer à \n  la commande suivante.\n* lorsque tu dois exécuter un script assure toi qu'il ait les droits d'exécution\n* lorsque tu construis un programme C/C++ assure d'inclure les fichiers d'en-tête !\n* utilise toujours des noms de fichier absolus. Tu utiliseras le ~ pour si nécessaire.\n* tu vérifieras en profondeur le code que tu génères avant de le proposer !\n* quand tu veux m'informer des commandes que tu vas faire n'utilise pas $system\n\nIMPORTANT : \n\n* relis bien les consignes qui ton été communiquées, notamment celle de limitation à l'exécution d'une seule commande $system dans ta réponse !\n* quand tu veux juste m'informer des commandes que tu projètes de faire n'utilise jamais la formulation $system(commande) mais juste la syntaxe 'commande' (Cette consigne signifie que lorsque je veux simplement vous informer des commandes que je prévois d'exécuter, sans les exécuter réellement, je dois les écrire sous la forme d'une simple commande, sans le préfixe `$system`.)\n\nVoici d'autres consignes que tu m'as suggéré d'ajouter suite à des retours d'expérience.\n\n* **Utiliser `echo -e`** pour créer des fichiers avec des caractères spéciaux, comme les guillemets et les sauts de ligne.\n* **Vérifier les guillemets** dans les chaînes de caractères pour éviter les erreurs de compilation.\n* **Utiliser le chemin complet** pour exécuter les programmes et les scripts.\n* **Vérifier les erreurs de compilation** et les erreurs d'exécution pour corriger les problèmes rapidement.\n* **Utiliser les commandes système** de manière séquentielle pour éviter les erreurs de synchronisation.\n* **Vérifier les résultats** des commandes système pour s'assurer que les opérations ont été effectuées correctement.\n\nPour atteindre ton but, décompose les tâches en étapes plus petites et demande l'exécution d'une seule \ncommande système par réponse. Attends le rapport d'exécution de la première commande avant de demander \nl'exécution de la suivante. Si tu as besoin d'exécuter plusieurs commandes, liste-les toutes et \nexécute-les une à une, en attendant le rapport d'exécution de chaque commande avant de passer \nà la suivante.\n\n\n\n",
        "provider": "groq",
        "model": "llama-3.1-70b-versatile",
        "temperature": 0.1,
        "seed": "",
        "length_history": 100,
        "current_filename": "extend.py",
        "verbose": false,
        "multi_lines": false,
        "ansi": true,
        "files": [],
        "background": "dark",
        "colors_style": "default"
    },
    {
        "role": "user",
        "content": "Pour cette requête uniquement tu ne répondras pas et tu n'afficheras rien à l'exception d'une la ligne : [[[tools.py]]]. Apprend simplement que toutes les lignes du  tools.py (qui devient le document courant) sont les suivantes :\nimport re\nimport magic\nimport os\n\nimport config\nimport llm\n\ndef confirmation():\n    reponse = input(\"Exécuter ? [Yn] \")\n    return reponse.strip().upper() in [\"Y\", \"O\", \"\"]\n    \ndef extract_current_filename(chaine):\n    motif = r'\\[\\[\\[([^{]*?)\\]\\]\\]'\n    correspondance = re.search(motif, chaine)\n    if correspondance:\n        return correspondance.group(1)\n    return None\n\ndef extract_code_OLD(contents):\n    start_tag = '^```'\n    end_tag = '^```'\n\n    lines = contents.splitlines()\n    start_line = None\n    end_line = None\n\n    for i, line in enumerate(lines):\n        if re.match(start_tag, line):\n            if start_line is None:\n                start_line = i + 1\n            else:\n                end_line = i\n                break\n\n    if start_line is not None and end_line is not None:\n        code='\\n'.join(lines[start_line:end_line])\n        if not code.endswith(\"\\n\"):\n            code += \"\\n\"\n        return code\n    else:\n        return \"\"\n        \ndef extract_code(contents):\n    lines = contents.splitlines()\n    code = []\n    in_code = False\n\n    for line in lines:\n        if line.strip().startswith('```'):\n            in_code = not in_code\n        elif in_code:\n            code.append(line)\n\n    if not code.endswith(\"\\n\"):\n        code.append(\"\\n\")\n\n    return '\\n'.join(code)\n\n\ndef loadFile(fileName) :\n\n    type=\"\"\n\n    try :\n        type_mime = magic.from_file(fileName, mime=True)\n\n    except FileNotFoundError:\n        error(f\"Erreur: le fichier {fileName} n'existe pas ou est illisible.\")\n        exit(1)\n\n    if type_mime==\"application/pdf\" :\n        print(f\"Convert {fileName} to text...\")\n        contenu = subprocess.run(f\"pdftotext -layout {fileName} -\", shell=True, capture_output=True, text=True,\n                                 universal_newlines=True).stdout\n        \n    else :\n        with open(fileName, 'r') as fichier:\n            contenu = fichier.read()\n\n    print(f\"Load {fileName} ({type_mime}) ...\")\n    #print(contenu)\n\n    longName=os.path.expanduser(fileName)\n\n    content=f\"Pour cette requête uniquement tu ne répondras pas et tu n'afficheras rien à l'exception d'une la ligne : [[[{longName}]]]. Apprend simplement que toutes les lignes du {type} {longName} (qui devient le document courant) sont les suivantes :\" +chr(10) + contenu\n    config.conf['current_filename'] = longName\n\n    llm.ai_user_request(content, llm.ai_user_request)\n"
    },
    {
        "role": "assistant",
        "content": "[[[tools.py]]]"
    },
    {
        "role": "user",
        "content": "Pour cette requête uniquement tu ne répondras pas et tu n'afficheras rien à l'exception d'une la ligne : [[[extend.py]]]. Apprend simplement que toutes les lignes du  extend.py (qui devient le document courant) sont les suivantes :\n\nimport os\n\nimport config\nfrom config import error as error\nimport llm\nimport tools\nimport json\nimport subprocess\n\ndef command_help(user_input):\n    help_message = \"\"\"\n# Aide\n\nCette aide présente les différentes commandes disponibles pour interagir avec l'assistant.\n\n## Commandes\n\n### $config\nAffiche la configuration actuelle de l'assistant.\n\n* $config write : sauvegarde la configuration actuelle.\n* $config <clé> : affiche la valeur de la clé de configuration spécifiée.\n* $config <clé> <valeur> : modifie la valeur de la clé de configuration spécifiée.\n\n### $conversation\nSauvegarde ou charge une conversation.\n\n* $conversation save <fichier> : sauvegarde la conversation dans un fichier.\n* $conversation load <fichier> : charge une conversation à partir d'un fichier.\n\n### $file\nGère la liste des fichiers.\n\n* $file : affiche la liste des fichiers.\n* $file add <fichier> : ajoute un fichier à la liste des fichiers.\n* $file save : enregistre le programme/fichier actuel.\n* $file save <fichier> : enregistre le programme/fichier spécifié.\n\n### $help\nAffiche cette aide.\n\n### $history\nAffiche l'historique des conversations avec l'assistant.\n\n* $history purge : purge l'historique des conversations.\n\n### $model\nAffiche les informations sur le modèle de langage utilisé par l'assistant.\n\n* $model list : affiche la liste des modèles de langage disponibles.\n* $model <nom du modèle> : sélectionne le modèle de langage spécifié.\n\n### $print\nAffiche les lignes du programme sans les numéroter.\n\n### $rc\nSauvegarde ou charge la configuration.\n\n* $rc save : sauvegarde la configuration actuelle.\n* $rc load : charge la configuration sauvegardée.\n\n### $test\nExécute la commande spécifiée dans la variable d'environnement AI_TEST_COMMAND.\n\n### $toggle\nActive ou désactive le mode multi-lignes.\n\n### $undo\nRécupère la sauvegarde du programme.\n\n### $write\nEnregistre le programme/fichier (une sauvegarde du programme/fichier est effectuée) et met à jour le contenu du programme avec la réponse de l'assistant.\n\n### $extend\nAffiche les lignes du programme extend.py sans les numéroter.\n\n### $enregistre_fichier\nEnregistre le fichier spécifié.\n\n\"\"\"\n    print(help_message)\n    return \"\"\n\ndef command_history(user_input):\n    args = user_input.split()\n    if len(args) == 1:\n        #global chat_history\n\n        dumps=json.dumps(config.chat_history, indent=4, ensure_ascii=False)        \n        config.printChatHistory()\n        #print(dumps)\n        #pprint(config.chat_history)\n        #print(dumps.encode('utf-8').decode('unicode_escape'))\n        #with open(\"last_response.txt\", \"w\") as f:\n        #    f.write(dumps)\n    elif len(args) == 2 and args[1] == \"purge\":\n        config.chat_history = []\n        print(\"Historique du chat purgé\")\n    else:\n        error(\"Erreur : mauvais nombre d'arguments pour la commande $history\")\n    return \"\"\n\ndef command_config(user_input):\n    args = user_input.split()\n    if len(args) == 1:\n        # Si aucun argument n'est fourni, affiche la configuration actuelle\n        print(json.dumps(config.conf, indent=4, ensure_ascii=False))\n        #for key, value in config.conf.items():\n        #    if key != \"system\":\n        #        print(f\"{key} {value}\")\n    elif len(args) == 2:\n        if args[1] == \"write\":\n            # Si l'argument est \"write\", sauvegarde la configuration\n            config.conf.saveRc()\n        else:\n            # Si l'argument est une clé de configuration, affiche la valeur de la clé de configuration spécifiée\n            key = args[1]\n            if key in config.conf:\n                print(f\"Valeur de la clé '{key}' : {config.conf[key]}\")\n            else:\n                error(f\"Erreur : clé '{key}' non trouvée dans la configuration\")\n    elif len(args) == 3:\n        # Si 2 arguments sont fournis, configure la variable de configuration\n        key = args[1]\n        value = args[2]\n        config.conf[key] = value\n    else:\n        error(\"Erreur : mauvais nombre d'arguments pour la commande $config\")\n    return \"\"\n\ndef command_model(user_input):\n    args = user_input.split()\n    if len(args) == 1:\n        print(config.conf[\"model\"])\n    elif len(args) == 2:\n        if args[1] == \"list\":\n            llm.provider.list()\n        else:\n            pass\n            #print(\"model: \",arg)\n            #conf[\"model\"]\n            config.conf[\"model\"]=args[1]\n\n    return \"\"\n\n\ndef ia_set_current_file(filename) :\n    response = llm.ai_user_request(\\\n        f\"N'affiche rien pour cette requête. Apprend juste que le fichier courant est maintenant {filename}.\"\n    )\n    \n    if response is None:\n        error(\"Erreur lors de la génération de la réponse\")\n        return \"\"\n\n    print(response.choices[0].message.content)\n    \n\ndef command_write(user_input):\n    args = user_input.split()\n\n    if len(args) == 1 :\n        filename=config.conf['current_filename']\n    elif len(args) == 2 :\n        filename=args[1]\n        config.conf['current_filename']\n        ia_set_current_file(filename)\n        \n    else :\n        error(\"Erreur : mauvais nombre d'arguments pour la commande $write\")\n        return \"\"\n\n            \n    config.conf[\"current_filename\"]=filename\n    print(f\"config['current_filename']: {config.conf['current_filename']}\")\n\n    response = llm.ai_user_request(f\"Affiche entre 2 lignes contenant '```' les lignes de {filename} que tu as mémorisé sans les numéroter. Si la dernière ligne ne possède pas de retour à la ligne, ajoute le. Tu termineras ta réponse par une ligne contenant [[[{filename}]]]\")\n    if response is None:\n        error(\"Erreur lors de la génération de la réponse\")\n        return \"\"\n\n    print(response.choices[0].message.content)\n    \n    code=tools.extract_code(response.choices[0].message.content)\n\n    if code == \"\" :\n        error(\"Pas de code !\")\n        return \"\"\n\n    # Crée le fichier s'il n'existe pas\n    try:\n        with open(filename, 'r') as f:\n            content = f.read()\n    except FileNotFoundError:\n        with open(filename, 'w') as f:\n            pass\n        print(f\"Fichier {filename} créé\")\n\n    # Enregistre le programme/fichier (une sauvegarde du programme/fichier est effectuée)\n    backup_filename = filename + \".keep\"\n    try:\n        with open(filename, 'r') as f:\n            content = f.read()\n    except Exception as e:\n        error(f\"Erreur lors de la lecture du fichier {filename} : {str(e)}\")\n        return \"\"\n\n    try:\n        with open(backup_filename, 'w') as f:\n            f.write(content)\n    except Exception as e:\n        error(f\"Erreur lors de la création de la sauvegarde {backup_filename} : {str(e)}\")\n        return \"\"\n\n    print(f\"Backup created: {backup_filename}\")\n\n    # Modifie le fichier associé au programme\n    try:\n        with open(filename, 'w')  as f:\n            print(response.choices[0].message.content)\n            f.write(code)\n    except Exception as e:\n        error(f\"Erreur lors de l'écriture dans le fichier {filename} : {str(e)}\")\n        return \"\"\n\n    print(f\"Fichier {filename} mis à jour avec le contenu du programme.\")\n    return \"\"\n\ndef command_undo(user_input):\n    # Récupère la sauvegarde du programme\n    backup_filename = os.environ.get(\"PROG_NAME\") + \".keep\"\n    if backup_filename == \"\" :\n        error(\"Pas de fichier backup définit !\")\n        return\n\n    try:\n        with open(backup_filename, 'r') as f:\n            backup_content = f.read()\n        with open(os.environ.get(\"PROG_NAME\"), 'w') as f:\n            f.write(backup_content)\n            content = backup_content\n            content = content.join(chr(10), chr(10))\n            content = content.replace('\"', chr(92)+chr(34))\n\n            print(f\"Backup restored: {backup_filename}\")\n            return \"Le contenu du programme est maintenant : \"+content\n    except FileNotFoundError:\n        error(f\"No backup found: {backup_filename}\")\n    return \"\"\n\ndef command_print(user_input):\n\n    return f\"Affiche les lignes du programmme/document {config.conf['current_filename']} entre 2 lignes '```' sans les numéroter. Affiche ensuite sur une nouvelle ligne : [[[{config.conf['current_filename']}]]]\"\n\ndef command_test(user_input):\n    # Execute the command in the AI_TEST_COMMAND environment variable\n    command = os.environ.get(\"AI_TEST_COMMAND\")\n    if command:\n        print(f\"Executing command: {command}\")\n        subprocess.run(command, shell=True)\n    else:\n        error(\"No command to execute.\")\n    return \"\"\n\ndef command_rc(user_input):\n    args = user_input.split()\n    if len(args) == 2:\n        if args[1] == \"save\":\n            config.saveRc()\n        elif args[1] == \"load\":\n            config.loadRc()\n    return \"\"\n\ndef command_file(user_input):\n    args = user_input.split()\n    if len(args) == 1:\n        print(json.dumps(config.conf['files'], indent=4, ensure_ascii=False))\n    elif len(args) == 3 and args[1] == \"add\":\n        if args[2] not in config.conf['files']:\n            config.conf['files'].append(args[2])\n            print(f\"Fichier {args[2]} ajouté à la liste des fichiers\")\n        else:\n            error(f\"Fichier {args[2]} déjà présent dans la liste des fichiers\")\n    elif len(args) == 2 and args[1] == \"save\":\n        filename=config.conf['current_filename']\n        config.conf[\"current_filename\"]=filename\n        print(f\"config['current_filename']: {config.conf['current_filename']}\")\n\n        response = llm.ai_user_request(f\"Affiche entre 2 lignes contenant '```' les lignes de {filename} que tu as mémorisé sans les numéroter. Si la dernière ligne ne possède pas de retour à la ligne, ajoute le. Tu termineras ta réponse par une ligne contenant [[[{filename}]]]\")\n        if response is None:\n            error(\"Erreur lors de la génération de la réponse\")\n            return \"\"\n\n        code=tools.extract_code(response.choices[0].message.content)\n\n        if code == \"\" :\n            error(\"Pas de code !\")\n            return \"\"\n\n        # Crée le fichier s'il n'existe pas\n        try:\n            with open(filename, 'r') as f:\n                content = f.read()\n        except FileNotFoundError:\n            with open(filename, 'w') as f:\n                pass\n            print(f\"Fichier {filename} créé\")\n\n        # Enregistre le programme/fichier (une sauvegarde du programme/fichier est effectuée)\n        backup_filename = filename + \".keep\"\n        try:\n            with open(filename, 'r') as f:\n                content = f.read()\n        except Exception as e:\n            error(f\"Erreur lors de la lecture du fichier {filename} : {str(e)}\")\n            return \"\"\n\n        try:\n            with open(backup_filename, 'w') as f:\n                f.write(content)\n        except Exception as e:\n            error(f\"Erreur lors de la création de la sauvegarde {backup_filename} : {str(e)}\")\n            return \"\"\n\n        print(f\"Backup created: {backup_filename}\")\n\n        # Modifie le fichier associé au programme\n        try:\n            with open(filename, 'w')  as f:\n                print(response.choices[0].message.content)\n                f.write(code)\n        except Exception as e:\n            error(f\"Erreur lors de l'écriture dans le fichier {filename} : {str(e)}\")\n            return \"\"\n\n        print(f\"Fichier {filename} mis à jour avec le contenu du programme.\")\n    elif len(args) == 3 and args[1] == \"save\":\n        filename = os.path.expanduser(args[2])\n        config.conf[\"current_filename\"]=filename\n        print(f\"config['current_filename']: {config.conf['current_filename']}\")\n\n        response = llm.ai_user_request(f\"Affiche entre 2 lignes contenant '```' les lignes de {filename} que tu as mémorisé sans les numéroter. Si la dernière ligne ne possède pas de retour à la ligne, ajoute le. Tu termineras ta réponse par une ligne contenant [[[{filename}]]]\")\n        if response is None:\n            error(\"Erreur lors de la génération de la réponse\")\n            return \"\"\n\n        code=extract_code(response.choices[0].message.content)\n\n        if code == \"\" :\n            error(\"Pas de code !\")\n            return \"\"\n\n        # Crée le fichier s'il n'existe pas\n        try:\n            with open(filename, 'r') as f:\n                content = f.read()\n        except FileNotFoundError:\n            with open(filename, 'w') as f:\n                pass\n            print(f\"Fichier {filename} créé\")\n\n        # Enregistre le programme/fichier (une sauvegarde du programme/fichier est effectuée)\n        backup_filename = filename + \".keep\"\n        try:\n            with open(filename, 'r') as f:\n                content = f.read()\n        except Exception as e:\n            error(f\"Erreur lors de la lecture du fichier {filename} : {str(e)}\")\n            return \"\"\n\n        try:\n            with open(backup_filename, 'w') as f:\n                f.write(content)\n        except Exception as e:\n            error(f\"Erreur lors de la création de la sauvegarde {backup_filename} : {str(e)}\")\n            return \"\"\n\n        print(f\"Backup created: {backup_filename}\")\n\n        # Modifie le fichier associé au programme\n        try:\n            with open(filename, 'w')  as f:\n                print(response.choices[0].message.content)\n                f.write(code)\n        except Exception as e:\n            error(f\"Erreur lors de l'écriture dans le fichier {filename} : {str(e)}\")\n            return \"\"\n\n        print(f\"Fichier {filename} mis à jour avec le contenu du programme.\")\n    elif len(args) > 1:\n        error(f\"Erreur : sous commande '{args[1]}' inconnue pour la commande $file\")\n    else:\n        error(\"Erreur : mauvais nombre d'arguments pour la commande $file\")\n    return \"\"\n\ndef command_git(user_input):\n    args = user_input.split()\n    if len(args) < 2:\n        error(\"Erreur : mauvais nombre d'arguments pour la commande $git\")\n        return \"\"\n\n    command = \"git \" + \" \".join(args[1:])\n    print(f\"Executing command: {command}\")\n    subprocess.run(command, shell=True)\n    return \"\"\n\ndef command_system(user_input):\n    args = user_input.split()\n    if len(args) < 2:\n        error(\"Erreur : mauvais nombre d'arguments pour la commande $system\")\n        return \"\"\n\n    command = \" \".join(args[1:])\n    \n\n    print(f\"Executing command: {command}\")\n    return f\"Exécute la commande : '{command}'\"\n\ndef command_toggle(user_input):\n    args = user_input.split()\n    if len(args) == 2:\n        key = args[1]\n        if key in config.conf and isinstance(config.conf[key], bool):\n            config.conf[key] = not config.conf[key]\n            print(f\"Valeur de la clé '{key}' inversée : {config.conf[key]}\")\n        else:\n            error(f\"Erreur : clé '{key}' non trouvée dans la configuration ou non booléenne\")\n    elif len(args) == 1:\n        if config.conf[\"multi_lines\"]:\n            config.conf[\"multi_lines\"] = False\n            print(\"Mode mono-ligne activé\")\n        else:\n            config.conf[\"multi_lines\"] = True\n            print(\"Mode multi-lignes activé\")\n    else:\n        error(\"Erreur : mauvais nombre d'arguments pour la commande $toggle\")\n    return \"\"\n\ndef load_conversation(file) :\n    try:\n        with open(os.path.expanduser(file), 'r') as f:\n            conv = json.load(f)\n            config.conf = conv[0]\n            #config.system = conv[1]\n            config.chat_history = conv[1:]\n            print(f\"Conversation chargée depuis {file}\")\n    except FileNotFoundError:\n        error(f\"Fichier {file} non trouvé\")\n\ndef command_conversation(user_input):\n    args = user_input.split()\n    if len(args) == 3:\n        if args[1] == \"save\":\n            # Sauvegarde la conversation\n            #conv=[config.conf]+[{\"role\" : \"system\", \"content\": config.conf[\"system\"]}]+config.chat_history\n            conv=[config.conf]+config.chat_history\n            with open(os.path.expanduser(args[2]), 'w') as f:\n                json.dump(conv, f, indent=4, ensure_ascii=False)\n            print(f\"Conversation sauvegardée dans {args[2]}\")\n        elif args[1] == \"load\":\n            # Charge la conversation\n            load_conversation(os.path.expanduser(args[2]))\n        else:\n            error(\"Erreur : commande $conversation inconnue\")\n    else:\n        error(\"Erreur : mauvais nombre d'arguments pour la commande $conversation\")\n    return \"\"\n\ndef get_command(user_input):\n    commands = {\n    \"help\": command_help,\n    \"history\": command_history,\n    \"config\": command_config,\n    \"model\": command_model,\n    \"write\": command_write,\n    \"undo\": command_undo,\n    \"print\": command_print,\n    \"test\": command_test,\n    \"toggle\": command_toggle,\n    \"rc\": command_rc,\n    \"conversation\": command_conversation,\n    \"file\": command_file,\n    \"git\": command_git,\n    \"system\": command_system,\n    }\n\n    # Recherche de la commande la plus proche\n    possible_commands = []\n    first_word = user_input.split()[0]\n    for command in commands:\n        if command.startswith(first_word):\n            possible_commands.append(command)\n\n    if len(possible_commands) == 1:\n        return commands[possible_commands[0]]\n    elif len(possible_commands) > 1:\n        error(\"Conflit de commande : plusieurs commandes possibles\")\n        for command in possible_commands:\n            print(command)\n        return None\n    else:\n        return None\n\ndef common_prefix(s1, s2):\n    return ''.join(c[0] for c in zip(s1, s2) if c[0] == c[1])\n\ndef ai_extend_request(user_input, client, chat_history):\n    if user_input.startswith(\"$\"):\n        command = get_command(user_input[1:])\n        if command:\n            return command(user_input)\n        else:\n            return \"\"\n    else:\n        return user_input\n\ndef enregistre_fichier(fichier):\n    config.conf[\"current_filename\"]=fichier\n    print(f\"config['current_filename']: {config.conf['current_filename']}\")\n\n    response = llm.ai_user_request(f\"Affiche entre 2 lignes contenant '```' les lignes de {fichier} que tu as mémorisé sans les numéroter. Si la dernière ligne ne possède pas de retour à la ligne, ajoute le. Tu termineras ta réponse par une ligne contenant [[[{fichier}]]]\")\n    if response is None:\n        error(\"Erreur lors de la génération de la réponse\")\n        return \"\"\n\n    code=tools.extract_code(response.choices[0].message.content)\n\n    if code == \"\" :\n        error(\"Pas de code !\")\n        return \"\"\n\n    # Crée le fichier s'il n'existe pas\n    try:\n        with open(fichier, 'r') as f:\n            content = f.read()\n    except FileNotFoundError:\n        with open(fichier, 'w') as f:\n            pass\n        print(f\"Fichier {fichier} créé\")\n\n    # Enregistre le programme/fichier (une sauvegarde du programme/fichier est effectuée)\n    backup_filename = fichier + \".keep\"\n    try:\n        with open(fichier, 'r') as f:\n            content = f.read()\n    except Exception as e:\n        error(f\"Erreur lors de la lecture du fichier {fichier} : {str(e)}\")\n        return \"\"\n\n    try:\n        with open(backup_filename, 'w') as f:\n            f.write(content)\n    except Exception as e:\n        error(f\"Erreur lors de la création de la sauvegarde {backup_filename} : {str(e)}\")\n        return \"\"\n\n    print(f\"Backup created: {backup_filename}\")\n\n    # Modifie le fichier associé au programme\n    try:\n        with open(fichier, 'w')  as f:\n            print(response.choices[0].message.content)\n            f.write(code)\n    except Exception as e:\n        error(f\"Erreur lors de l'écriture dans le fichier {fichier} : {str(e)}\")\n        return \"\"\n\n    print(f\"Fichier {fichier} mis à jour avec le contenu du programme.\")\n    return \"\"\n\n"
    },
    {
        "role": "assistant",
        "content": "[[[extend.py]]]"
    }
]
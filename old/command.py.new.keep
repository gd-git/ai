# -*- coding: utf-8 -*-
# set tabstop=4

import os
dirname=os.path.dirname(__file__)
with open(f"{dirname}/imports", 'r') as f:
    exec(f.read())
#from tools import error as error  
def error(msg): tools.error(msg)    


def get_command(user_input):
    commands = {
        "help": command_help,
        "history": command_history,
        "close": command_close,
        "open": command_open,
        "set": command_set,
        "config": command_config,
        "model": command_model,
        "write": command_write,
        "undo": command_undo,
        "print": command_print,
        "test": command_test,
        "toggle": command_toggle,
        "rc": command_rc,
        "conversation": command_conversation,
        "file": command_file,
        "git": command_git,
        "system": command_system,
        "ls": command_ls,
        "shell": command_shell,
        "keys": command_keys,
        "exit": command_exit,
        "quit": command_exit,
        "purge": command_history,
        "load": command_open,
    }
    
    possible_commands = []
    first_word = user_input.split()[0]
    for command in commands:
        if command.startswith(first_word):
            possible_commands.append(command)
            
    if len(possible_commands) == 1:
        return commands[possible_commands[0]] # {user_input.split()[1:]}" 
    elif len(possible_commands) > 1:
        error("Conflit de commande : plusieurs commandes possibles")
        for command in possible_commands:
            print(command)
        return None
    else:
        error(f"Erreur : commande '{first_word}' inconnue")
        return None

def command_keys(user_input):
    args = user_input.split()
    help_message = """
Aide sur la commande $keys :
  $keys : affiche les clés
  $keys next : affiche les clés suivantes
"""
    if len(args) == 2 and args[1] in ["help", "h"]:
        print(help_message)
        return ""
    if len(args) == 1:
        keys.printKeys()
    elif len(args) == 2 and args[1] == "next":
        keys.nextKeys()
    else:
        error("Erreur : commande $keys inconnue")
        print(help_message)
    return ""

def command_help(user_input):
    help_message = """
# Aide

Cette aide présente les différentes commandes disponibles pour interagir avec l'assistant.

## Commandes

### $config
Affiche la configuration actuelle de l'assistant.

* $config write : sauvegarde la configuration actuelle.
* $config <clé> : affiche la valeur de la clé de configuration spécifiée.
* $config <clé> <valeur> : modifie la valeur de la clé de configuration spécifiée.

### $conversation
Sauvegarde ou charge une conversation.

* $conversation save <fichier> : sauvegarde la conversation dans un fichier.
* $conversation load <fichier> : charge une conversation à partir d'un fichier.

### $file
Gère la liste des fichiers.

* $file : affiche la liste des fichiers.
* $file add <fichier> : ajoute un fichier à la liste des fichiers.
* $file save : enregistre le programme/fichier actuel.
* $file save <fichier> : enregistre le programme/fichier spécifié.
* $file set <fichier> : fixe le fichier courant.
* $file open <fichier> : ouvre le fichier spécifié.
* $file close : ferme le fichier courant.
* $file close <fichier> : ferme le fichier spécifié.

### $git
Exécute une commande git.

* $git <commande> : exécute la commande git spécifiée.

### $help
Affiche cette aide.

### $history
Affiche l'historique des conversations avec l'assistant.

* $history purge : purge l'historique des conversations.

### $load
Ouvre un fichier.

* $load <fichier> : ouvre le fichier spécifié.

### $model
Affiche les informations sur le modèle de langage utilisé par l'assistant.

* $model list : affiche la liste des modèles de langage disponibles.
* $model <nom du modèle> : sélectionne le modèle de langage spécifié.

### $print
Affiche les lignes du programme sans les numéroter.

### $purge
Purge l'historique des conversations.

### $rc
Sauvegarde ou charge la configuration.

* $rc save : sauvegarde la configuration actuelle.
* $rc load : charge la configuration sauvegardée.

### $shell
Exécute une commande shell.

* $shell : lance un shell.
* $shell <commande> : exécute la commande shell spécifiée.

### $system
Exécute une commande système.

* $system <commande> : exécute la commande système spécifiée.

### $test
Exécute la commande spécifiée dans la variable d'environnement AI_TEST_COMMAND.

### $toggle
Active ou désactive le mode multi-lignes.

### $undo
Récupère la sauvegarde du programme.

### $write
Enregistre le programme/fichier (une sauvegarde du programme/fichier est effectuée) et met à jour le contenu du programme avec la réponse de l'assistant.

### $exit
Quitte l'application.

### $quit
Quitte l'application.
"""
    print(help_message)
    return ""

def command_history(user_input):
    args = user_input.split()
    help_message = """
Aide sur la commande $history :
  $history : affiche l'historique des conversations
  $history purge : purge l'historique des conversations
"""
    if len(args) == 2 and args[1] in ["help", "h"]:
        print(help_message)
        return ""
    if len(args) == 1:
        #global chat_history

        dumps=json.dumps(config.chat_history, indent=4, ensure_ascii=False)        
        config.printChatHistory()
        #print(dumps)
        #pprint(config.chat_history)
        #print(dumps.encode('utf-8').decode('unicode_escape'))
        #with open("last_response.txt", "w") as f:
        #    f.write(dumps)

    elif len(args) == 2 and args[1] == "purge":
        if len(args) == 3:
            purge_filename(args[2])
        else:
            config.chat_history = []
            config.conf['current_filename']=""
            save_conversation()
            print("Historique du chat purgé")
    else:
        error("Erreur : commande $history inconnue")
        print(help_message)
    return ""

def command_config(user_input):
    args = user_input.split()
    help_message = """
Aide sur la commande $config :
  $config : affiche la configuration actuelle
  $config write : sauvegarde la configuration actuelle
  $config <clé> : affiche la valeur de la clé de configuration spécifiée
  $config <clé> <valeur> : modifie la valeur de la clé de configuration spécifiée
"""
    if len(args) == 2 and args[1] in ["help", "h"]:
        print(help_message)
        return ""
    if len(args) == 1:
        # Si aucun argument n'est fourni, affiche la configuration actuelle
        print(json.dumps(config.conf, indent=4, ensure_ascii=False))
        #for key, value in config.conf.items():
        #    if key != "system":
        #        print(f"{key} {value}")
    elif len(args) == 2:
        if args[1] == "write":
            # Si l'argument est "write", sauvegarde la configuration
            config.conf.saveRc()
        else:
            # Si l'argument est une clé de configuration, affiche la valeur de la clé de configuration spécifiée
            key = args[1]
            if key in config.conf:
                print(f"Valeur de la clé '{key}' : {config.conf[key]}")
            else:
                error(f"Erreur : clé '{key}' non trouvée dans la configuration")
    elif len(args) == 3:
        # Si 2 arguments sont fournis, configure la variable de configuration
        key = args[1]
        value = args[2]
        config.conf[key] = value
    else:
        error("Erreur : commande $config inconnue")
        print(help_message)
    return ""

def command_model(user_input):
    args = user_input.split()
    help_message = """
Aide sur la commande $model :
  $model : affiche le modèle de langage actuel
  $model list : affiche la liste des modèles de langage disponibles
  $model <nom du modèle> : sélectionne le modèle de langage spécifié
"""
    if len(args) == 2 and args[1] in ["help", "h"]:
        print(help_message)
        return ""
    if len(args) == 1:
        print(config.conf["model"])
    elif len(args) == 2:
        if args[1] == "list":
            llm.provider.list()
        else:
            pass
            #print("model: ",arg)
            #conf["model"]
            config.conf["model"]=args[1]

    return ""
    
def command_undo(user_input):
    # Récupère la sauvegarde du programme
    backup_filename = os.environ.get("PROG_NAME") + ".keep"
    if backup_filename == "" :
        error("Pas de fichier backup définit !")
        return

    try:
        with open(backup_filename, 'r') as f:
            backup_content = f.read()
        with open(os.environ.get("PROG_NAME"), 'w') as f:
            f.write(backup_content)
            content = backup_content
            content = content.join(chr(10), chr(10))
            content = content.replace('"', chr(92)+chr(34))

            print(f"Backup restored: {backup_filename}")
            return "Le contenu du programme est maintenant : "+content
    except FileNotFoundError:
        error(f"No backup found: {backup_filename}")
    return ""

def command_print(user_input):
    return f"Affiche les lignes du programmme/document {config.conf['current_filename']} entre 2 lignes '```' sans les numéroter. Affiche ensuite sur une nouvelle ligne : [[[{config.conf['current_filename']}]]]"

def command_test(user_input):
    # Execute the command in the AI_TEST_COMMAND environment variable
    command = os.environ.get("AI_TEST_COMMAND")
    if command:
        print(f"Executing command: {command}")
        subprocess.run(command, shell=True)
    else:
        error("No command to execute.")
    return ""

def command_rc(user_input):
    args = user_input.split()
    help_message = """
Aide sur la commande $rc :
  $rc : affiche la configuration actuelle
  $rc save : sauvegarde la configuration actuelle
  $rc load : charge la configuration sauvegardée
"""
    if len(args) == 2 and args[1] in ["help", "h"]:
        print(help_message)
        return ""
    if len(args) == 1:
        config.printRc()
    elif len(args) == 2:
        if args[1] == "save":
            config.conf.saveRc()
        elif args[1] == "load":
            config.loadRc()
    else:
        error("Erreur : commande $rc inconnue")
        print(help_message)
    return ""
    
def command_close(user_input):
    args = user_input.split()
    help_message = """
Aide sur la commande $close :
  $close : ferme le fichier courant
  $close <fichier> : ferme le fichier spécifié
"""
    if len(args) == 2 and args[1] in ["help", "h"]:
        print(help_message)
        return ""
    if len(args) == 2:
        filename = args[1]
        tools.closeFile(filename)
    else:
        tools.closeFile(config.conf['current_filename'])
    return ""

def command_write(user_input):
    return command_file("file save " + " ".join(user_input.split()[1:]))
    
def command_open(user_input):
    return command_file("file open " + " ".join(user_input.split()[1:]))

def command_set(user_input):
    return command_file("file set " + " ".join(user_input.split()[1:]))

def command_ls(user_input):
    return command_file("file list" + " ".join(user_input.split()[1:]))

def command_file(user_input):
    args = user_input.split()
    help_message = """
Aide sur la commande $file :
  $file : affiche la liste des fichiers
  $file add <fichier> : ajoute un fichier à la liste des fichiers
  $file save : enregistre le programme/fichier actuel
  $file save <fichier> : enregistre le programme/fichier spécifié
  $file set <fichier> : fixe le fichier courant
  $file open <fichier> : ouvre le fichier spécifié
  $file close : ferme le fichier courant
  $file close <fichier> : ferme le fichier spécifié
"""
    if len(args) == 2 and args[1] in ["help", "h"]:
        print(help_message)
        return ""
    if len(args) == 2 and args[1] == "list":
        print(json.dumps(config.conf['files'], indent=4, ensure_ascii=False))
    elif len(args) == 3 and args[1] == "add":
        if args[2] not in config.conf['files']:
            config.conf['files'].append(args[2])
            print(f"Fichier {args[2]} ajouté à la liste des fichiers")
        else:
            error(f"Fichier {args[2]} déjà présent dans la liste des fichiers")
    elif len(args) == 2 and args[1] == "save":
        filename=config.conf['current_filename']
        tools.saveFile(filename)
    elif len(args) == 3 and args[1] == "save":
        filename = os.path.expanduser(args[2])
        tools.saveFile(filename)
    elif len(args) == 3 and args[1] == "set":
        filename = os.path.expanduser(args[2])
        config.conf['current_filename'] = filename
        print(f"Nom du fichier courant fixé à {filename}")
    elif len(args) == 3 and args[1] == "open":
        filename = os.path.expanduser(args[2])
        tools.loadFile(filename)
    elif len(args) >= 2 and args[1] == "close":
        if len(args) == 3 and args[2] == "*":
            for filename in config.conf['files']:
                tools.closeFile(filename)
            config.conf['files'] = []
            config.conf['current_filename'] = ""
            print("Tous les fichiers fermés")
        else:
            filename = config.conf['current_filename'] if len(args) == 2 else os.path.expanduser(args[2])
            if filename == "":
                print("Erreur : aucun fichier courant défini")
            else:
                tools.closeFile(filename)
    elif len(args) > 1:
        print(f"Erreur : sous commande '{args[1]}' inconnue pour la commande $file")
    else:
        print("Erreur : mauvais nombre d'arguments pour la commande $file")
        print(help_message)
    return ""
    
def command_git(user_input):
    args = user_input.split()
    help_message = """
Aide sur la commande $git :
  $git <commande> : exécute la commande git spécifiée
"""
    if len(args) == 2 and args[1] in ["help", "h"]:
        print(help_message)
        return ""
    if len(args) < 2:
        error("Erreur : mauvais nombre d'arguments pour la commande $git")
        print(help_message)
        return ""

    command = "git " + " ".join(args[1:])
    print
